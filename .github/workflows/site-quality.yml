name: "Site Quality Checks"

# Trigger on pushes, pull requests, and monthly schedule
on:
  push:
    branches:
      - main
      - dev
  pull_request:
    branches:
      - main
      - dev
  schedule:
    - cron: '0 0 1 * *'  # 1st of every month, 00:00 UTC

permissions:
  contents: read
  security-events: write

jobs:
  #################################################################
  # Enforce signed commits
  #################################################################
  verify-signatures:
    name: Verify commit signatures
    runs-on: ubuntu-latest
    outputs:
      verified: ${{ steps.verify.outputs.verified }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Verify signed commits
        id: verify
        run: |
          echo "Verifying GPG-signed commits..."
          git fetch origin main || true
          UNSIGNED=$(git log --pretty=format:'%h %G? %s' origin/main..HEAD | awk '$2 != "G" { print $1 " " $0 }' || true)
          if [ -n "$UNSIGNED" ]; then
            echo "Found unsigned commits:"
            echo "$UNSIGNED"
            echo "::set-output name=verified::false"
            exit 1
          fi
          echo "All commits are properly signed."
          echo "::set-output name=verified::true"

  #################################################################
  # CodeQL security analysis
  #################################################################
  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    needs: verify-signatures
    if: needs.verify-signatures.outputs.verified == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript,python

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Run CodeQL analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "security"
          output: results.sarif

      - name: Fail on high severity issues
        run: |
          if grep -q '"level": "error"' results.sarif; then
            echo "High severity CodeQL issues detected!"
            exit 1
          else
            echo "No high severity CodeQL findings."
          fi

  #################################################################
  # SBOM generation + Grype + OSV scanning
  #################################################################
  vulnerability-scan:
    name: SBOM + Grype + OSV Scanning
    runs-on: ubuntu-latest
    needs: verify-signatures
    if: needs.verify-signatures.outputs.verified == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v5

      # --------------------------
      # Pin Go version ‚â•1.24.9 (avoid stdlib CVEs)
      # --------------------------
      - name: Set up Go 1.24.9
        uses: actions/setup-go@v5
        with:
          go-version: '1.24.9'

      - name: Show Go version & environment
        run: |
          echo "Go version:"
          go version
          echo
          echo "Environment:"
          uname -a || true
          lsb_release -a || true

      # --------------------------
      # Install Syft & Grype
      # --------------------------
      - name: Install Syft
        run: |
          echo "Installing Syft..."
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | bash -s -- -b /usr/local/bin
          syft version

      - name: Install Grype
        run: |
          echo "Installing Grype..."
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | bash -s -- -b /usr/local/bin
          grype version

      - name: Install jq
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      # --------------------------
      # Recursively update go.mod files to fix known vulnerable modules
      # --------------------------
      - name: Update vulnerable Go dependencies recursively
        shell: bash
        run: |
          set -euo pipefail
          echo "üîç Finding all go.mod files..."
          mapfile -t mods < <(find . -name go.mod)
          if [ "${#mods[@]}" -eq 0 ]; then
            echo "No go.mod files found."
          else
            for gm in "${mods[@]}"; do
              dir=$(dirname "$gm")
              echo
              echo "=== Processing $gm (dir=$dir) ==="
              pushd "$dir" >/dev/null || continue

              echo "üì• go mod download (refresh cache)"
              go mod download || echo "go mod download warning in $dir"

              echo "‚¨ÜÔ∏è Attempting safe (patch) upgrades for vulnerable modules in $dir"
              # Try patch-level upgrades to avoid breaking changes. If a specific version is required, go get with @version will set it.
              # We attempt to set the patched versions requested.
              if go list -m all | grep -q 'github.com/opencontainers/selinux'; then
                go get github.com/opencontainers/selinux@v1.13.0 || echo "‚ö†Ô∏è selinux upgrade failed in $dir"
              else
                echo "selinux not present in $dir (skipping)"
              fi

              if go list -m all | grep -q 'github.com/containerd/containerd'; then
                go get github.com/containerd/containerd@v1.7.29 || echo "‚ö†Ô∏è containerd upgrade failed in $dir"
              else
                echo "containerd not present in $dir (skipping)"
              fi

              echo "üßπ go mod tidy"
              go mod tidy || echo "go mod tidy failed in $dir"

              echo "üîé Current selinux/containerd entries (if present):"
              go list -m all | grep -E 'opencontainers/selinux|containerd' || echo "None found in $dir"

              popd >/dev/null
            done
          fi

      # --------------------------
      # Verify dependency graph quickly (debug)
      # --------------------------
      - name: Verify dependency graph
        run: |
          echo "Verifying Go dependency graph (root module):"
          go list -m all | head -n 50 || echo "go list failed for root module (maybe no root go.mod)"

      # --------------------------
      # Regenerate SBOM (full Syft JSON) after updates
      # --------------------------
      - name: Regenerate SBOM with Syft (full SBOM)
        run: |
          echo "Generating Syft SBOM (full JSON) of repository..."
          # use the repo root as input; syft will inspect code and module artifacts
          syft . -o json > sbom.json
          echo "SBOM size (bytes): $(wc -c sbom.json | awk '{print $1}')"
          echo "Top-level keys in SBOM:"
          jq 'keys' sbom.json

      # --------------------------
      # Confirm that Go modules were updated correctly (debug)
      # --------------------------
      - name: Verify fixed module versions
        run: |
          echo "Confirming Go dependency patch levels (searching all modules):"
          # this will show entries if they exist somewhere in module graph
          find . -name go.mod -print -execdir sh -c 'echo "---- in $(pwd) ----"; go list -m all | grep -E "opencontainers/selinux|containerd" || echo "None"' \;

      # --------------------------
      # Grype scan (fail on Critical/High)
      # --------------------------
      - name: Run Grype vulnerability scan and fail on Critical/High
        shell: bash
        run: |
          set -euo pipefail
          echo "Running Grype vulnerability scan..."
          grype sbom:./sbom.json -o table || true

          echo "Checking for Critical/High vulnerabilities..."
          CRIT_HIGH=$(grype sbom:./sbom.json -o json | jq '[.matches[] | select(.vulnerability.severity=="Critical" or .vulnerability.severity=="High")] | length')
          echo "Critical/High count: $CRIT_HIGH"
          if [ "$CRIT_HIGH" -gt 0 ]; then
            echo "Detected $CRIT_HIGH Critical/High vulnerabilities via Grype:"
            grype sbom:./sbom.json -o json | jq -r '.matches[] | select(.vulnerability.severity=="Critical" or .vulnerability.severity=="High") | "‚Ä¢ \(.artifact.name) \(.artifact.version) ‚Üí \(.vulnerability.id) (\(.vulnerability.severity))"'
            exit 1
          else
            echo "No Critical/High vulnerabilities detected by Grype."
          fi

      # --------------------------
      # OSV API vulnerability scan (defense-in-depth)
      # --------------------------
      - name: Run OSV API vulnerability check
        shell: bash
        run: |
          set -euo pipefail
          echo "Running OSV API vulnerability scan..."
          FOUND=0
          # Iterate artifacts from Syft SBOM
          jq -c '.artifacts[] | {name: .name, version: .version}' sbom.json | while read -r pkg; do
            NAME=$(echo "$pkg" | jq -r '.name')
            VERSION=$(echo "$pkg" | jq -r '.version')
            if [ -z "$NAME" ] || [ -z "$VERSION" ]; then
              continue
            fi
            # Query OSV API
            RESPONSE=$(curl -s -X POST "https://api.osv.dev/v1/query" \
              -H "Content-Type: application/json" \
              -d "{\"package\": {\"name\": \"$NAME\"}, \"version\": \"$VERSION\"}")
            if echo "$RESPONSE" | jq -e '.vulns' >/dev/null 2>&1; then
              echo "Vulnerabilities found in $NAME@$VERSION (OSV):"
              echo "$RESPONSE" | jq -r '.vulns[] | "‚Ä¢ \(.id): \(.summary // \"(no summary)\")"'
              FOUND=1
            fi
          done
          if [ "$FOUND" -eq 1 ]; then
            echo "Vulnerabilities detected by OSV."
            exit 1
          else
            echo "No vulnerabilities detected by OSV."
          fi
